# data-structures
В данном репозитории содержится 4 программы:

1. Реализация структуры данных дек на кольцевом буфере.
Есть два указателя:
head - индекс, по которому можно добавлять элемент в начало дека
tail - индекс, по которому можно добавлять элемент в конец дека
Соответственно, обращаясь к этим же указателям, отнимая единицу, можно извлекать элемент из дека.
Если дек переполняется, то выводится сообщение об ошибке: "error".

2. Реализация хеш-таблицы.
Я реализовала массив массивов списка с двумя элементами. Внешний массив я сделала максимальной длины max_size = 10^5.
В него вложен массив, поскольку я боролась с коллизиями методом цепочек. Каждый массива списков изначально заполнены как [-1, -1], что означает, что данного элемента нет (был удален).
Зачем нужны пары? На первом месте в списке находится индекс, который фиксируется. Поскольку у разных чисел могут быть одинаковые
остатки от деления на max_size, нужно запоминать какое именно число дало такой остаток. На втором месте в списке находится value - зарплата сотрудника.
Так как мы применяем всего 3 операции: put, get, delete - для каждой операции я написала отдельную функцию. При удалении сотрудника из базы список в массиве становится равен [-1, -1].

3. Реализация очереди, написанной с использованием связного списка.
Поддерживает 3 операции:
get() — выводит элемент, находящийся в голове очереди, и удаляет его. Если очередь пуста, то выводит «error»
put(x) — добавляет число x в очередь
size() — выводит текущий размер очереди

4. Реализация стека, который удаляет максимальный элемент за О(1).
Поддерживает 3 операции:
push(x) — добавляет число x в стек
pop() — удаляет число с вершины стека
get_max() — печатает максимальное число в стеке
